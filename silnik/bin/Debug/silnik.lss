
bin\Debug\silnik.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000374  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .fuse         00000003  00820000  00820000  000003e8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .debug_aranges 00000040  00000000  00000000  000003eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000186  00000000  00000000  0000042b  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000351  00000000  00000000  000005b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000143  00000000  00000000  00000902  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000005d4  00000000  00000000  00000a45  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000160  00000000  00000000  0000101c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000195  00000000  00000000  0000117c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000070  00000000  00000000  00001311  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  4c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  68:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  6c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  70:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  74:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  78:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  7c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  80:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  84:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  88:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 e7       	ldi	r30, 0x74	; 116
  a0:	f3 e0       	ldi	r31, 0x03	; 3
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 30       	cpi	r26, 0x00	; 0
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
  b2:	0e 94 8f 00 	call	0x11e	; 0x11e <main>
  b6:	0c 94 b8 01 	jmp	0x370	; 0x370 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <ioinit>:
#define LED2_ON LED2_PORT &= ~LED2_PIN      //Wlaczenie LEDa 2
#define LED2_OFF LED2_PORT |= LED2_PIN      //Wylaczenie LEDa 2
#define LED2_TOG LED2_PORT ^= (1<<LED2_PIN) //Zmiana stanu LEDa 2
void ioinit(void)           //Inicjalizacja wejsc/wyjsc
{
	M1_DDR |= (1<<M1_IN1)|(1<<M1_IN2)|(1<<M2_IN1)|(1<<M2_IN2); //jako wyjscia
  be:	8a b3       	in	r24, 0x1a	; 26
  c0:	88 67       	ori	r24, 0x78	; 120
  c2:	8a bb       	out	0x1a, r24	; 26
	M1_P_DDR |= (1<<M1_P)|(1<<M2_P); //piny od PWMa jako wyjscia
  c4:	82 b1       	in	r24, 0x02	; 2
  c6:	88 61       	ori	r24, 0x18	; 24
  c8:	82 b9       	out	0x02, r24	; 2

	PG3_SLEEP_DDR |= (1<<PG3_SLEEP); //jako wyjscie
  ca:	a4 e6       	ldi	r26, 0x64	; 100
  cc:	b0 e0       	ldi	r27, 0x00	; 0
  ce:	8c 91       	ld	r24, X
  d0:	88 60       	ori	r24, 0x08	; 8
  d2:	8c 93       	st	X, r24
	PG3_SLEEP_PORT &= ~(1<<PG3_SLEEP); //uspienie silnikow
  d4:	e5 e6       	ldi	r30, 0x65	; 101
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	80 81       	ld	r24, Z
  da:	87 7f       	andi	r24, 0xF7	; 247
  dc:	80 83       	st	Z, r24
	FS_AB_DDR &= ~(1<<FS_AB);  //pinod FS jako wejscie
  de:	a2 98       	cbi	0x14, 2	; 20

	STEP_CLK_DDR |= (1<<STEP_CLK); //jako wyjscie
  e0:	bf 9a       	sbi	0x17, 7	; 23
	STEP_DIR_DDR |= (1<<STEP_DIR); //jako wyjscie
  e2:	8c 91       	ld	r24, X
  e4:	84 60       	ori	r24, 0x04	; 4
  e6:	8c 93       	st	X, r24
	STEP_ENABLE_DDR |= (1<<STEP_ENABLE); //jako wyjscie
  e8:	8c 91       	ld	r24, X
  ea:	80 61       	ori	r24, 0x10	; 16
  ec:	8c 93       	st	X, r24

	LED1_DDR |= (1<<LED1)|(1<<LED2); //jako wyjscia
  ee:	81 b3       	in	r24, 0x11	; 17
  f0:	80 6c       	ori	r24, 0xC0	; 192
  f2:	81 bb       	out	0x11, r24	; 17

	M3_DDR |= (1<<M3_FIN)|(1<<M3_RIN); //jako wyjscia
  f4:	84 b3       	in	r24, 0x14	; 20
  f6:	83 60       	ori	r24, 0x03	; 3
  f8:	84 bb       	out	0x14, r24	; 20
	M3_P_DDR |= (1<<M3_P);//jako wyjscie
  fa:	bd 9a       	sbi	0x17, 5	; 23

	M4_DDR |= (1<<M4_FIN)|(1<<M4_RIN);//jako wyjscia
  fc:	84 b3       	in	r24, 0x14	; 20
  fe:	8c 60       	ori	r24, 0x0C	; 12
 100:	84 bb       	out	0x14, r24	; 20
	M4_P_DDR |= (1<<M4_P); //jako wyjscie
 102:	be 9a       	sbi	0x17, 6	; 23

	M5_DDR |= (1<<M5_FIN)|(1<<M5_RIN); //jako wyjscia
 104:	84 b3       	in	r24, 0x14	; 20
 106:	80 63       	ori	r24, 0x30	; 48
 108:	84 bb       	out	0x14, r24	; 20
	M56_P_DDR |= (1<<M56_P); //jako wyjscie
 10a:	15 9a       	sbi	0x02, 5	; 2
	M6_DDR |= (1<<M6_FIN)|(1<<M6_RIN); //jako wyjscie
 10c:	84 b3       	in	r24, 0x14	; 20
 10e:	80 6c       	ori	r24, 0xC0	; 192
 110:	84 bb       	out	0x14, r24	; 20

	KEY_DDR |= (1<<KEY1)|(1<<KEY2); //klucze tranzystorowe jako wyjscia
 112:	81 b3       	in	r24, 0x11	; 17
 114:	80 63       	ori	r24, 0x30	; 48
 116:	81 bb       	out	0x11, r24	; 17
	DDRF = 0x00; //caly port jako wejscie (konieczne gdy uzywamy ADC)
 118:	10 92 61 00 	sts	0x0061, r1
}
 11c:	08 95       	ret

0000011e <main>:

int main(void)
{
    //Inicjalizacje
    ioinit();               //Inicjalizujemy wejscia jako wejscia a wyjscia jako wyjscia
 11e:	0e 94 5f 00 	call	0xbe	; 0xbe <ioinit>
    MOTOR_init();           //Inicjalizcja Motora (3, 4, 5 i 6)
 122:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <MOTOR_init>
    MOTOR34_init();         //Inna inicjalizacja innego motora (3 i 4)
 126:	0e 94 49 01 	call	0x292	; 0x292 <MOTOR34_init>
    MOTOR56_init();         //Jeszcze inniejsza inicjalizacja jeszcze inniejszego motora (5 i 6)
 12a:	0e 94 90 01 	call	0x320	; 0x320 <MOTOR56_init>


    LED1_ON;
 12e:	97 98       	cbi	0x12, 7	; 18
    LED2_OFF;
 130:	96 9a       	sbi	0x12, 6	; 18
	DDRC = 0x00; //port C jako wejï¿½cie
 132:	14 ba       	out	0x14, r1	; 20
    PORTC |= 0b00000000; //piny nie podciï¿½gane do rezystorï¿½w
 134:	85 b3       	in	r24, 0x15	; 21
 136:	85 bb       	out	0x15, r24	; 21
while(1){
    DDRC = 0x00; //port C jako wejï¿½cie
 138:	14 ba       	out	0x14, r1	; 20
    PORTC |= 0b00000000; //piny nie podciï¿½gane do rezystorï¿½w
 13a:	85 b3       	in	r24, 0x15	; 21
 13c:	85 bb       	out	0x15, r24	; 21
    if(PINC == 0b00000001) // ostro prawo
 13e:	83 b3       	in	r24, 0x13	; 19
 140:	81 30       	cpi	r24, 0x01	; 1
 142:	19 f4       	brne	.+6      	; 0x14a <main+0x2c>
    {
         MOTOR_drive(255,-255);
 144:	8f ef       	ldi	r24, 0xFF	; 255
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	37 c0       	rjmp	.+110    	; 0x1b8 <main+0x9a>
    }
    else if(PINC==0b00000011) //lekko prawo
 14a:	83 b3       	in	r24, 0x13	; 19
 14c:	83 30       	cpi	r24, 0x03	; 3
 14e:	39 f4       	brne	.+14     	; 0x15e <main+0x40>
    {
         MOTOR_drive(255,0);
 150:	8f ef       	ldi	r24, 0xFF	; 255
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	60 e0       	ldi	r22, 0x00	; 0
 156:	70 e0       	ldi	r23, 0x00	; 0
 158:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <MOTOR_drive>
 15c:	32 c0       	rjmp	.+100    	; 0x1c2 <main+0xa4>
    }
    else if(PINC==0b00001100) // lekko lewo
 15e:	83 b3       	in	r24, 0x13	; 19
 160:	8c 30       	cpi	r24, 0x0C	; 12
 162:	19 f4       	brne	.+6      	; 0x16a <main+0x4c>
    {
         MOTOR_drive(0,255);
 164:	80 e0       	ldi	r24, 0x00	; 0
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0b c0       	rjmp	.+22     	; 0x180 <main+0x62>
    }
    else if(PINC==0b00001000)  // ostro lewo
 16a:	83 b3       	in	r24, 0x13	; 19
 16c:	88 30       	cpi	r24, 0x08	; 8
 16e:	19 f4       	brne	.+6      	; 0x176 <main+0x58>
    {
         MOTOR_drive(-255,255);
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	9f ef       	ldi	r25, 0xFF	; 255
 174:	05 c0       	rjmp	.+10     	; 0x180 <main+0x62>
    }
    else if(PINC==0b00001111)  // cala naprzï¿½d
 176:	83 b3       	in	r24, 0x13	; 19
 178:	8f 30       	cpi	r24, 0x0F	; 15
 17a:	29 f4       	brne	.+10     	; 0x186 <main+0x68>
    {
         MOTOR_drive(255,255);
 17c:	8f ef       	ldi	r24, 0xFF	; 255
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	6f ef       	ldi	r22, 0xFF	; 255
 182:	70 e0       	ldi	r23, 0x00	; 0
 184:	e9 cf       	rjmp	.-46     	; 0x158 <main+0x3a>
    }
    else if(PINC==0b00001101)  // lekko naprzï¿½d               !!!!!!!!!!!!!!!!!!
 186:	83 b3       	in	r24, 0x13	; 19
 188:	8d 30       	cpi	r24, 0x0D	; 13
 18a:	29 f4       	brne	.+10     	; 0x196 <main+0x78>
    {
         MOTOR_drive(200,200);
 18c:	88 ec       	ldi	r24, 0xC8	; 200
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	68 ec       	ldi	r22, 0xC8	; 200
 192:	70 e0       	ldi	r23, 0x00	; 0
 194:	e1 cf       	rjmp	.-62     	; 0x158 <main+0x3a>
    }
    else if(PINC==0b00000110)  // cala wstecz
 196:	83 b3       	in	r24, 0x13	; 19
 198:	86 30       	cpi	r24, 0x06	; 6
 19a:	19 f4       	brne	.+6      	; 0x1a2 <main+0x84>
    {
         MOTOR_drive(-255,-255);
 19c:	81 e0       	ldi	r24, 0x01	; 1
 19e:	9f ef       	ldi	r25, 0xFF	; 255
 1a0:	0b c0       	rjmp	.+22     	; 0x1b8 <main+0x9a>
    }
    else if(PINC==0b00001110) //lewo wstecz
 1a2:	83 b3       	in	r24, 0x13	; 19
 1a4:	8e 30       	cpi	r24, 0x0E	; 14
 1a6:	19 f4       	brne	.+6      	; 0x1ae <main+0x90>
    {
        MOTOR_drive(-255,0);
 1a8:	81 e0       	ldi	r24, 0x01	; 1
 1aa:	9f ef       	ldi	r25, 0xFF	; 255
 1ac:	d3 cf       	rjmp	.-90     	; 0x154 <main+0x36>
    }
    else if(PINC==0b00000111) //prawo wstecz
 1ae:	83 b3       	in	r24, 0x13	; 19
 1b0:	87 30       	cpi	r24, 0x07	; 7
 1b2:	29 f4       	brne	.+10     	; 0x1be <main+0xa0>
    {
        MOTOR_drive(0,-255);
 1b4:	80 e0       	ldi	r24, 0x00	; 0
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	61 e0       	ldi	r22, 0x01	; 1
 1ba:	7f ef       	ldi	r23, 0xFF	; 255
 1bc:	cd cf       	rjmp	.-102    	; 0x158 <main+0x3a>
    }
    else
    {
        LED1_OFF;
 1be:	97 9a       	sbi	0x12, 7	; 18
        LED2_ON;
 1c0:	96 98       	cbi	0x12, 6	; 18
    }
    return 0;
}
}
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	08 95       	ret

000001c8 <MOTOR_init>:
	Inicjalizacja timera 3 do generowania sygnalu PWM (Pulse Width Modulation)
o rozdzielczosci 8 bitow i czestotliwosci ok 4kHz
*******************************************************************************/
void MOTOR_init(void)
{
  	TCCR3A |= (1<<COM3A1)|(1<<COM3B1)|(1<<COM3A0)|(1<<COM3B0)|(1<<WGM30);
 1c8:	eb e8       	ldi	r30, 0x8B	; 139
 1ca:	f0 e0       	ldi	r31, 0x00	; 0
 1cc:	80 81       	ld	r24, Z
 1ce:	81 6f       	ori	r24, 0xF1	; 241
 1d0:	80 83       	st	Z, r24
    TCCR3B |= (1<<CS31); //8bit Phase Correct PWM inverting mode dla silników kó³
 1d2:	ea e8       	ldi	r30, 0x8A	; 138
 1d4:	f0 e0       	ldi	r31, 0x00	; 0
 1d6:	80 81       	ld	r24, Z
 1d8:	82 60       	ori	r24, 0x02	; 2
 1da:	80 83       	st	Z, r24
						//preskaler przez 8 co da czêstotliwoœæ ok 4kHz

  	PG3_SLEEP_PORT &= ~(1<<PG3_SLEEP); //uspienie silnikow
 1dc:	e5 e6       	ldi	r30, 0x65	; 101
 1de:	f0 e0       	ldi	r31, 0x00	; 0
 1e0:	80 81       	ld	r24, Z
 1e2:	87 7f       	andi	r24, 0xF7	; 247
 1e4:	80 83       	st	Z, r24
}
 1e6:	08 95       	ret

000001e8 <MOTOR_drive>:
kierunek obrotu silnika (kierunki lewo i prawo sa umowne) w zaleznosci od znaku
wartosci zadanej oraz ogranicza wartosc zadana tak aby nie nastepowalo
przepelnienie.
*******************************************************************************/
void MOTOR_drive(signed int left_speed,signed int right_speed)
{
 1e8:	9c 01       	movw	r18, r24
	if((left_speed != 0) || (right_speed != 0))
 1ea:	00 97       	sbiw	r24, 0x00	; 0
 1ec:	19 f4       	brne	.+6      	; 0x1f4 <MOTOR_drive+0xc>
 1ee:	61 15       	cp	r22, r1
 1f0:	71 05       	cpc	r23, r1
 1f2:	d9 f0       	breq	.+54     	; 0x22a <MOTOR_drive+0x42>
		PG3_SLEEP_PORT |= (1<<PG3_SLEEP); //wybudzenie driverow DC ze stanu uspienia
 1f4:	80 91 65 00 	lds	r24, 0x0065
 1f8:	88 60       	ori	r24, 0x08	; 8
 1fa:	80 93 65 00 	sts	0x0065, r24

	if(left_speed > 0) //obot w prawo
 1fe:	12 16       	cp	r1, r18
 200:	13 06       	cpc	r1, r19
 202:	1c f4       	brge	.+6      	; 0x20a <MOTOR_drive+0x22>
	{
		M1_PORT |= (1<<M1_IN1);
 204:	db 9a       	sbi	0x1b, 3	; 27
		M1_PORT &= ~(1<<M1_IN2);
 206:	dc 98       	cbi	0x1b, 4	; 27
 208:	05 c0       	rjmp	.+10     	; 0x214 <MOTOR_drive+0x2c>
	}
	else if(left_speed < 0) //obrot w lewo
 20a:	21 15       	cp	r18, r1
 20c:	31 05       	cpc	r19, r1
 20e:	11 f0       	breq	.+4      	; 0x214 <MOTOR_drive+0x2c>
	{
		M1_PORT &= ~(1<<M1_IN1);
 210:	db 98       	cbi	0x1b, 3	; 27
		M1_PORT |= (1<<M1_IN2);
 212:	dc 9a       	sbi	0x1b, 4	; 27
	}

	if(right_speed > 0) //obrot w prawo
 214:	16 16       	cp	r1, r22
 216:	17 06       	cpc	r1, r23
 218:	1c f4       	brge	.+6      	; 0x220 <MOTOR_drive+0x38>
	{
		M2_PORT |= (1<<M2_IN1);
 21a:	dd 9a       	sbi	0x1b, 5	; 27
		M2_PORT &= ~(1<<M2_IN2);
 21c:	de 98       	cbi	0x1b, 6	; 27
 21e:	05 c0       	rjmp	.+10     	; 0x22a <MOTOR_drive+0x42>
	}
	else if(right_speed<0) //obrot w lewo
 220:	61 15       	cp	r22, r1
 222:	71 05       	cpc	r23, r1
 224:	11 f0       	breq	.+4      	; 0x22a <MOTOR_drive+0x42>
	{
		M2_PORT &= ~(1<<M2_IN1);
 226:	dd 98       	cbi	0x1b, 5	; 27
		M2_PORT |= (1<<M2_IN2);
 228:	de 9a       	sbi	0x1b, 6	; 27
	}

    if(abs(right_speed) >= PWM_MAX) //ograniczenie wartosci maksymalnej
 22a:	77 ff       	sbrs	r23, 7
 22c:	03 c0       	rjmp	.+6      	; 0x234 <MOTOR_drive+0x4c>
 22e:	70 95       	com	r23
 230:	61 95       	neg	r22
 232:	7f 4f       	sbci	r23, 0xFF	; 255
 234:	6f 3f       	cpi	r22, 0xFF	; 255
 236:	71 05       	cpc	r23, r1
 238:	1c f0       	brlt	.+6      	; 0x240 <MOTOR_drive+0x58>
		OCR3A = PWM_MAX;
 23a:	8f ef       	ldi	r24, 0xFF	; 255
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	02 c0       	rjmp	.+4      	; 0x244 <MOTOR_drive+0x5c>
	else
		OCR3A = (unsigned char)(abs(right_speed));
 240:	86 2f       	mov	r24, r22
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	90 93 87 00 	sts	0x0087, r25
 248:	80 93 86 00 	sts	0x0086, r24


    if(abs(left_speed) >= PWM_MAX) //ograniczenie wartosci maksymalnej
 24c:	c9 01       	movw	r24, r18
 24e:	37 ff       	sbrs	r19, 7
 250:	03 c0       	rjmp	.+6      	; 0x258 <MOTOR_drive+0x70>
 252:	90 95       	com	r25
 254:	81 95       	neg	r24
 256:	9f 4f       	sbci	r25, 0xFF	; 255
 258:	8f 3f       	cpi	r24, 0xFF	; 255
 25a:	91 05       	cpc	r25, r1
 25c:	1c f0       	brlt	.+6      	; 0x264 <MOTOR_drive+0x7c>
		OCR3B = PWM_MAX;
 25e:	8f ef       	ldi	r24, 0xFF	; 255
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	01 c0       	rjmp	.+2      	; 0x266 <MOTOR_drive+0x7e>
	else
		OCR3B = (unsigned char)(abs(left_speed));
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	90 93 85 00 	sts	0x0085, r25
 26a:	80 93 84 00 	sts	0x0084, r24
 26e:	08 95       	ret

00000270 <MOTOR_break>:
	Realizuje hamowanie przez zwarcie obu wyprowadzen silnikow do masy. Przydatna
da awaryjnego zatrzymania robota.
*******************************************************************************/
void MOTOR_break(void)
{
     MOTOR_drive(255,255);
 270:	8f ef       	ldi	r24, 0xFF	; 255
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	6f ef       	ldi	r22, 0xFF	; 255
 276:	70 e0       	ldi	r23, 0x00	; 0
 278:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <MOTOR_drive>
     M1_PORT |=  (1<<M1_IN1);
 27c:	db 9a       	sbi	0x1b, 3	; 27
     M1_PORT |=  (1<<M1_IN2);
 27e:	dc 9a       	sbi	0x1b, 4	; 27
     M2_PORT |=  (1<<M2_IN1);
 280:	dd 9a       	sbi	0x1b, 5	; 27
     M2_PORT |=  (1<<M2_IN2);
 282:	de 9a       	sbi	0x1b, 6	; 27
}
 284:	08 95       	ret

00000286 <MOTOR_sleep>:
krokowego w stan uspienia (wspolne wyprowadzenie PG3_SLEEP), obnizajac pobor
pradu
*******************************************************************************/
void MOTOR_sleep(void)
{
	PG3_SLEEP_PORT &= ~(1<<PG3_SLEEP); //przejscie driverow DC w stan uspienia
 286:	e5 e6       	ldi	r30, 0x65	; 101
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	80 81       	ld	r24, Z
 28c:	87 7f       	andi	r24, 0xF7	; 247
 28e:	80 83       	st	Z, r24
}
 290:	08 95       	ret

00000292 <MOTOR34_init>:
o rozdzielczosci 8 bitow i czestotliwosci ok 4kHz dla driverow silnikow DC
znajdujacych sie na plycie rozszerzen MOBOT-EXP MCB
*******************************************************************************/
void MOTOR34_init(void)
{
	TCCR1A = (1<<COM1A1)|(1<<COM1B1)|(1<<WGM30);
 292:	81 ea       	ldi	r24, 0xA1	; 161
 294:	8f bd       	out	0x2f, r24	; 47
    TCCR1B = (1<<CS11); //8bit Phase Correct PWM,
 296:	82 e0       	ldi	r24, 0x02	; 2
 298:	8e bd       	out	0x2e, r24	; 46
						//preskaler przez 8 co da czêstotliwoœæ ok 4kHz
}
 29a:	08 95       	ret

0000029c <MOTOR3_set_speed>:
nastepowalo przepelnienie.
*******************************************************************************/
void MOTOR3_set_speed(signed int speed)
{

	if(speed > 0) //obrot w prawo
 29c:	18 16       	cp	r1, r24
 29e:	19 06       	cpc	r1, r25
 2a0:	1c f4       	brge	.+6      	; 0x2a8 <MOTOR3_set_speed+0xc>
	{
		M3_PORT |= (1<<M3_RIN);
 2a2:	a9 9a       	sbi	0x15, 1	; 21
		M3_PORT &= ~(1<<M3_FIN);
 2a4:	a8 98       	cbi	0x15, 0	; 21
 2a6:	04 c0       	rjmp	.+8      	; 0x2b0 <MOTOR3_set_speed+0x14>
	}
	else if(speed < 0) //obrot w lewo
 2a8:	00 97       	sbiw	r24, 0x00	; 0
 2aa:	11 f0       	breq	.+4      	; 0x2b0 <MOTOR3_set_speed+0x14>
	{
		M3_PORT &= ~(1<<M3_RIN);
 2ac:	a9 98       	cbi	0x15, 1	; 21
		M3_PORT |= (1<<M3_FIN);
 2ae:	a8 9a       	sbi	0x15, 0	; 21
	}

    if(abs(speed)>=PWM34_MAX) //ograniczenie wartosci maksymalnej
 2b0:	97 ff       	sbrs	r25, 7
 2b2:	03 c0       	rjmp	.+6      	; 0x2ba <MOTOR3_set_speed+0x1e>
 2b4:	90 95       	com	r25
 2b6:	81 95       	neg	r24
 2b8:	9f 4f       	sbci	r25, 0xFF	; 255
 2ba:	8f 3f       	cpi	r24, 0xFF	; 255
 2bc:	91 05       	cpc	r25, r1
 2be:	1c f0       	brlt	.+6      	; 0x2c6 <MOTOR3_set_speed+0x2a>
		OCR1A = PWM34_MAX;
 2c0:	8f ef       	ldi	r24, 0xFF	; 255
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	01 c0       	rjmp	.+2      	; 0x2c8 <MOTOR3_set_speed+0x2c>
	else
		OCR1A = (unsigned char)(abs(speed));
 2c6:	90 e0       	ldi	r25, 0x00	; 0
 2c8:	9b bd       	out	0x2b, r25	; 43
 2ca:	8a bd       	out	0x2a, r24	; 42
 2cc:	08 95       	ret

000002ce <MOTOR3_break>:
	Realizuje hamowanie przez zwarcie obu wyprowadzen silnika do masy. Przydatna
da awaryjnego zatrzymania.
*******************************************************************************/
void MOTOR3_break(void)
{
	M3_PORT |= ((1<<M3_RIN)|(1<<M3_FIN));
 2ce:	85 b3       	in	r24, 0x15	; 21
 2d0:	83 60       	ori	r24, 0x03	; 3
 2d2:	85 bb       	out	0x15, r24	; 21
	OCR1A = PWM34_MAX;
 2d4:	8f ef       	ldi	r24, 0xFF	; 255
 2d6:	90 e0       	ldi	r25, 0x00	; 0
 2d8:	9b bd       	out	0x2b, r25	; 43
 2da:	8a bd       	out	0x2a, r24	; 42
}
 2dc:	08 95       	ret

000002de <MOTOR4_set_speed>:
nastepowalo przepelnienie.
*******************************************************************************/
void MOTOR4_set_speed(signed int speed)
{

	if(speed > 0) //obrot w prawo
 2de:	18 16       	cp	r1, r24
 2e0:	19 06       	cpc	r1, r25
 2e2:	1c f4       	brge	.+6      	; 0x2ea <MOTOR4_set_speed+0xc>
	{
		M4_PORT |= (1<<M4_RIN);
 2e4:	ab 9a       	sbi	0x15, 3	; 21
		M4_PORT &= ~(1<<M4_FIN);
 2e6:	aa 98       	cbi	0x15, 2	; 21
 2e8:	04 c0       	rjmp	.+8      	; 0x2f2 <MOTOR4_set_speed+0x14>
	}
	else if(speed < 0) //obrot w lewo
 2ea:	00 97       	sbiw	r24, 0x00	; 0
 2ec:	11 f0       	breq	.+4      	; 0x2f2 <MOTOR4_set_speed+0x14>
	{
		M4_PORT &= ~(1<<M4_RIN);
 2ee:	ab 98       	cbi	0x15, 3	; 21
		M4_PORT |= (1<<M4_FIN);
 2f0:	aa 9a       	sbi	0x15, 2	; 21
	}

    if(abs(speed)>=PWM34_MAX) //ograniczenie wartosci maksymalnej
 2f2:	97 ff       	sbrs	r25, 7
 2f4:	03 c0       	rjmp	.+6      	; 0x2fc <MOTOR4_set_speed+0x1e>
 2f6:	90 95       	com	r25
 2f8:	81 95       	neg	r24
 2fa:	9f 4f       	sbci	r25, 0xFF	; 255
 2fc:	8f 3f       	cpi	r24, 0xFF	; 255
 2fe:	91 05       	cpc	r25, r1
 300:	1c f0       	brlt	.+6      	; 0x308 <MOTOR4_set_speed+0x2a>
		OCR1B = PWM34_MAX;
 302:	8f ef       	ldi	r24, 0xFF	; 255
 304:	90 e0       	ldi	r25, 0x00	; 0
 306:	01 c0       	rjmp	.+2      	; 0x30a <MOTOR4_set_speed+0x2c>
	else
		OCR1B = (unsigned char)(abs(speed));
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	99 bd       	out	0x29, r25	; 41
 30c:	88 bd       	out	0x28, r24	; 40
 30e:	08 95       	ret

00000310 <MOTOR4_break>:
	Realizuje hamowanie przez zwarcie obu wyprowadzen silnika do masy. Przydatna
da awaryjnego zatrzymania.
*******************************************************************************/
void MOTOR4_break(void)
{
	M4_PORT |= ((1<<M4_RIN)|(1<<M4_FIN));
 310:	85 b3       	in	r24, 0x15	; 21
 312:	8c 60       	ori	r24, 0x0C	; 12
 314:	85 bb       	out	0x15, r24	; 21
	OCR1B = PWM34_MAX;
 316:	8f ef       	ldi	r24, 0xFF	; 255
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	99 bd       	out	0x29, r25	; 41
 31c:	88 bd       	out	0x28, r24	; 40
}
 31e:	08 95       	ret

00000320 <MOTOR56_init>:
zasilania. Funkcja nie inicjalizuje timera, dlatego do generowania przebiegu
nalezy wywolac dodatkowo funkcje MOTOR_init();
*******************************************************************************/
void MOTOR56_init()
{
	TCCR3A |= (1<<COM3C1); //reszta jest juz zainicjowana w funkcji MOTOR_init
 320:	eb e8       	ldi	r30, 0x8B	; 139
 322:	f0 e0       	ldi	r31, 0x00	; 0
 324:	80 81       	ld	r24, Z
 326:	88 60       	ori	r24, 0x08	; 8
 328:	80 83       	st	Z, r24

	OCR3C = PWM56;
 32a:	80 e8       	ldi	r24, 0x80	; 128
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	90 93 83 00 	sts	0x0083, r25
 332:	80 93 82 00 	sts	0x0082, r24
}
 336:	08 95       	ret

00000338 <MOTOR5_right>:
Opis:
	Ustawia kierunek obrotu silnika 5 w prawo (kierunek umowny)
*******************************************************************************/
void MOTOR5_right(void)
{
	M5_PORT |= (1<<M5_RIN);
 338:	ad 9a       	sbi	0x15, 5	; 21
	M5_PORT &= ~(1<<M5_FIN);
 33a:	ac 98       	cbi	0x15, 4	; 21
}
 33c:	08 95       	ret

0000033e <MOTOR5_left>:
Opis:
	Ustawia kierunek obrotu silnika 5 w lewo (kierunek umowny)
*******************************************************************************/
void MOTOR5_left(void)
{
	M5_PORT &= ~(1<<M5_RIN);
 33e:	ad 98       	cbi	0x15, 5	; 21
	M5_PORT |= (1<<M5_FIN);
 340:	ac 9a       	sbi	0x15, 4	; 21
}
 342:	08 95       	ret

00000344 <MOTOR5_stop>:
Opis:
	Powoduje zatrzymanie silnika 5 prezez odlaczenie zasilania
*******************************************************************************/
void MOTOR5_stop(void)
{
	M5_PORT &= ~((1<<M5_RIN)|(1<<M5_FIN));
 344:	85 b3       	in	r24, 0x15	; 21
 346:	8f 7c       	andi	r24, 0xCF	; 207
 348:	85 bb       	out	0x15, r24	; 21
}
 34a:	08 95       	ret

0000034c <MOTOR5_break>:
Opis:
	Realizuje hamowanie silnika 5 prezez zwarcie obu wyprowadzen do masy
*******************************************************************************/
void MOTOR5_break(void)
{
	M5_PORT |= ((1<<M5_RIN)|(1<<M5_FIN));
 34c:	85 b3       	in	r24, 0x15	; 21
 34e:	80 63       	ori	r24, 0x30	; 48
 350:	85 bb       	out	0x15, r24	; 21
}
 352:	08 95       	ret

00000354 <MOTOR6_right>:
Opis:
	Ustawia kierunek obrotu silnika 6 w prawo (kierunek umowny)
*******************************************************************************/
void MOTOR6_right(void)
{
	M6_PORT |= (1<<M6_RIN);
 354:	af 9a       	sbi	0x15, 7	; 21
	M6_PORT &= ~(1<<M6_FIN);
 356:	ae 98       	cbi	0x15, 6	; 21
}
 358:	08 95       	ret

0000035a <MOTOR6_left>:
Opis:
	Ustawia kierunek obrotu silnika 6 w lewo (kierunek umowny)
*******************************************************************************/
void MOTOR6_left(void)
{
	M6_PORT &= ~(1<<M6_RIN);
 35a:	af 98       	cbi	0x15, 7	; 21
	M6_PORT |= (1<<M6_FIN);
 35c:	ae 9a       	sbi	0x15, 6	; 21
}
 35e:	08 95       	ret

00000360 <MOTOR6_stop>:
Opis:
	Powoduje zatrzymanie silnika 6 prezez odlaczenie zasilania
*******************************************************************************/
void MOTOR6_stop(void)
{
	M6_PORT &= ~((1<<M6_RIN)|(1<<M6_FIN));
 360:	85 b3       	in	r24, 0x15	; 21
 362:	8f 73       	andi	r24, 0x3F	; 63
 364:	85 bb       	out	0x15, r24	; 21
}
 366:	08 95       	ret

00000368 <MOTOR6_break>:
Opis:
	Realizuje hamowanie silnika 6 prezez zwarcie obu wyprowadzen do masy
*******************************************************************************/
void MOTOR6_break(void)
{
	M6_PORT |= ((1<<M6_RIN)|(1<<M6_FIN));
 368:	85 b3       	in	r24, 0x15	; 21
 36a:	80 6c       	ori	r24, 0xC0	; 192
 36c:	85 bb       	out	0x15, r24	; 21
}
 36e:	08 95       	ret

00000370 <_exit>:
 370:	f8 94       	cli

00000372 <__stop_program>:
 372:	ff cf       	rjmp	.-2      	; 0x372 <__stop_program>
